import Counter from '../../components/Counter';

# useState Hook'u Nedir?

React'te **useState** hook'u, bileÅŸen iÃ§inde deÄŸiÅŸken deÄŸerleri yÃ¶netmek iÃ§in kullanÄ±lÄ±r. En temel Ã¶rneklerden biri bir sayaÃ§ (counter) uygulamasÄ±dÄ±r. KullanÄ±cÄ± butona tÄ±kladÄ±ÄŸÄ±nda sayÄ±nÄ±n arttÄ±ÄŸÄ±nÄ± gÃ¶rmek isteriz:

<Counter />

Ä°ÅŸte bu sayaÃ§ bileÅŸeninin kodu:

```jsx
import React from 'react';

function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      DeÄŸer: {count}
    </button>
  );
}

export default Counter;
```

Bu kodda birkaÃ§ Ã¶nemli nokta var. Gelin, bunlarÄ± adÄ±m adÄ±m inceleyelim.

---

## **useState KullanÄ±mÄ±**

Bir state (durum) deÄŸiÅŸkeni oluÅŸturmak iÃ§in **useState** fonksiyonunu kullanÄ±rÄ±z. **useState** ÅŸu iki deÄŸeri dÃ¶ndÃ¼rÃ¼r:

1. **Mevcut state deÄŸeri** â€“ Ã–rneÄŸimizde `count` olarak adlandÄ±rdÄ±k.
2. **State'i gÃ¼ncellemek iÃ§in bir fonksiyon** â€“ Bunu da `setCount` olarak adlandÄ±rdÄ±k.

Ã–rneÄŸin:

```jsx
const [count, setCount] = React.useState(0);
```

Burada `count` baÅŸlangÄ±Ã§ta `0` olarak ayarlandÄ±. `setCount` fonksiyonu ile bu deÄŸeri gÃ¼ncelleyebiliriz.

---

## **Array Destructuring ile State KullanÄ±mÄ±**

EÄŸer bu yapÄ± size yabancÄ± geliyorsa, aynÄ± kodu daha geleneksel bir ÅŸekilde ÅŸÃ¶yle yazabiliriz:

```jsx
const countArray = React.useState(0);
const count = countArray[0];
const setCount = countArray[1];
```

Ancak, genellikle **destructuring** kullanarak yazmak Ã§ok daha pratiktir.

---

## **State DeÄŸiÅŸkenlerini AdlandÄ±rma KurallarÄ±**

State deÄŸiÅŸkenini ve gÃ¼ncelleme fonksiyonunu nasÄ±l adlandÄ±racaÄŸÄ±nÄ±z tamamen size baÄŸlÄ±dÄ±r. Ã–rneÄŸin:

```jsx
const [hello, world] = React.useState(0);
```

Ancak yaygÄ±n olarak ÅŸu format tercih edilir:

```jsx
const [user, setUser] = React.useState();
const [errorMessage, setErrorMessage] = React.useState();
const [flowerBouquet, setFlowerBouquet] = React.useState();
```

Burada birinci deÄŸiÅŸken state'in adÄ±nÄ±, ikinci deÄŸiÅŸken ise onu gÃ¼ncellemek iÃ§in kullanÄ±lan fonksiyonu temsil eder.

---

## **useState'i Ä°mport Etme YÃ¶ntemleri**

BazÄ± kaynaklarda ÅŸu iki farklÄ± yazÄ±mÄ± gÃ¶rebilirsiniz:

```jsx
import React, { useState } from 'react';

function App() {
  const [num, setNum] = useState(0);
  return <div>{num}</div>;
}
```

veya

```jsx
import React from 'react';

function App() {
  const [num, setNum] = React.useState(0);
  return <div>{num}</div>;
}
```

Her iki yÃ¶ntem de tamamen aynÄ±dÄ±r. Ä°lk yÃ¶ntemde `useState` doÄŸrudan iÃ§e aktarÄ±lmÄ±ÅŸtÄ±r. Ä°kinci yÃ¶ntemde ise `React.useState` ÅŸeklinde Ã§aÄŸrÄ±lmÄ±ÅŸtÄ±r. Hangisini kullanacaÄŸÄ±nÄ±z tamamen tercihinize baÄŸlÄ±dÄ±r.

---

## **BaÅŸlangÄ±Ã§ DeÄŸeri (Initial Value) Belirleme**

State deÄŸiÅŸkenine baÅŸlangÄ±Ã§ deÄŸeri atayabiliriz:

```jsx
const [count, setCount] = React.useState(1);
console.log(count); // 1
```

Ya da bir fonksiyon kullanarak baÅŸlangÄ±Ã§ deÄŸerini hesaplayabiliriz:

```jsx
const [count, setCount] = React.useState(() => {
  return 1 + 1;
});

console.log(count); // 2
```

Bu yÃ¶ntem, Ã¶zellikle **pahalÄ± hesaplamalar** gerektiÄŸinde kullanÄ±ÅŸlÄ± olabilir. Ã–rneÄŸin, Local Storage'dan veri okumak iÃ§in:

```jsx
const [count, setCount] = React.useState(() => {
  return window.localStorage.getItem('saved-count');
});
```

Bu sayede, Local Storage'dan veri okuma iÅŸlemi yalnÄ±zca **ilk render'da** gerÃ§ekleÅŸir, her render'da tekrarlanmaz.

---

## **Fonksiyon ile BaÅŸlangÄ±Ã§ DeÄŸeri KullanmanÄ±n Ã–nemi**

Ä°ki farklÄ± baÅŸlangÄ±Ã§ deÄŸeri belirleme yÃ¶ntemi arasÄ±ndaki farkÄ± anlamak iÃ§in aÅŸaÄŸÄ±daki kodlarÄ± karÅŸÄ±laÅŸtÄ±ralÄ±m:

**1. Direkt olarak deÄŸeri belirleme:**

```jsx
const [count, setCount] = React.useState(
  window.localStorage.getItem('saved-count')
);
```

Bu kodda `window.localStorage.getItem` her render'da Ã§alÄ±ÅŸÄ±r.

**2. Fonksiyon kullanarak baÅŸlangÄ±Ã§ deÄŸeri belirleme:**

```jsx
const [count, setCount] = React.useState(() => {
  return window.localStorage.getItem('saved-count');
});
```

Bu kodda ise React, fonksiyonu **sadece ilk render'da Ã§alÄ±ÅŸtÄ±rÄ±r**. Sonraki render'larda bu hesaplama tekrar edilmez, dolayÄ±sÄ±yla gereksiz performans kaybÄ± Ã¶nlenmiÅŸ olur.

Bu farkÄ± anlamak iÃ§in ÅŸu Ã¶rneÄŸi dÃ¼ÅŸÃ¼nebiliriz:

```jsx
function run() {
  console.log('Merhaba');
}
```

Bu fonksiyon her Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda konsola `"Merhaba"` yazdÄ±rÄ±r.

Ancak aÅŸaÄŸÄ±daki gibi bir yapÄ± kullanÄ±rsak:

```jsx
function run() {
  const sayHi = () => {
    console.log('Merhaba');
  };
}
```

Burada `sayHi` fonksiyonu her Ã§aÄŸrÄ±da **oluÅŸturulur ama Ã§aÄŸrÄ±lmaz**. React'teki ikinci yÃ¶ntemde de benzer bir mantÄ±k vardÄ±r. BaÅŸlangÄ±Ã§ deÄŸerini hesaplayan fonksiyon sadece **ilk render'da Ã§alÄ±ÅŸÄ±r**, sonraki render'larda tekrar Ã§alÄ±ÅŸtÄ±rÄ±lmaz.

---

## **SonuÃ§**

- **useState** hook'u, React bileÅŸenlerinde deÄŸiÅŸkenleri yÃ¶netmek iÃ§in kullanÄ±lÄ±r.
- **Ä°lk deÄŸer** doÄŸrudan atanabilir veya bir fonksiyon aracÄ±lÄ±ÄŸÄ±yla hesaplanabilir.
- **Fonksiyon kullanÄ±mÄ±**, gereksiz hesaplamalarÄ± Ã¶nlemek iÃ§in avantaj saÄŸlar.
- **State deÄŸiÅŸkenleri iÃ§in anlamlÄ± ve aÃ§Ä±klayÄ±cÄ± isimlendirme** tercih edilmelidir.

React ile dinamik arayÃ¼zler oluÅŸtururken **useState** temel araÃ§larÄ±mÄ±zdan biri olacaktÄ±r. ğŸ¯
