# React'te Asenkron Durum GÃ¼ncellemeleri

React'te state (durum) gÃ¼ncellemeleri asenkron olarak Ã§alÄ±ÅŸÄ±r. Bu durum, yeni baÅŸlayanlar iÃ§in kafa karÄ±ÅŸtÄ±rÄ±cÄ± olabilir. Hadi, bunu adÄ±m adÄ±m Ã¶ÄŸrenelim!

### Ã–rnek: Ä°lk TÄ±klamada Beklenmeyen SonuÃ§

AÅŸaÄŸÄ±daki React kodunu inceleyelim. Butona ilk kez tÄ±klandÄ±ÄŸÄ±nda, konsolda hangi deÄŸerin yazdÄ±rÄ±lmasÄ±nÄ± beklersiniz?

```jsx
function App() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <p>You've clicked {count} times.</p>
      <button
        onClick={() => {
          setCount(count + 1);
          console.log(count);
        }}
      >
        Click me!
      </button>
    </>
  );
}
```

SeÃ§enekler: `0`, `1`, `undefined`, `None of the above`

Cevap: **0** ğŸ¯

Bu size garip mi geldi? Ä°lk tÄ±klamada `count` deÄŸerini **1** olarak gÃ¶rmek istemez miydik? Ama React bize `0` dÃ¶ndÃ¼rÃ¼yor. Ä°ÅŸte nedeni! ğŸ‘‡

### State GÃ¼ncellemeleri Neden Hemen GerÃ§ekleÅŸmez?

React'te `setCount` gibi state gÃ¼ncelleyici fonksiyonlar **hemen Ã§alÄ±ÅŸmaz**. Bunun yerine, Reactâ€™e **"bu state deÄŸiÅŸecek"** mesajÄ± veririz. React ise mevcut iÅŸlemler (Ã¶rneÄŸin, tÄ±klama iÅŸlemi) tamamlanana kadar deÄŸiÅŸikliÄŸi uygulamaz.

Bu yÃ¼zden, `console.log(count)` ifadesi **gÃ¼ncellenmemiÅŸ eski deÄŸeri** gÃ¶sterir.

### GÃ¼ncellenmiÅŸ DeÄŸeri KullanmanÄ±n DoÄŸru Yolu

EÄŸer gÃ¼ncellenmiÅŸ deÄŸere hemen eriÅŸmek istiyorsak, onu bir deÄŸiÅŸkene atayarak kullanabiliriz:

```jsx
function App() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <p>You've clicked {count} times.</p>
      <button
        onClick={() => {
          const nextCount = count + 1;
          setCount(nextCount);
          console.log(nextCount);
        }}
      >
        Click me!
      </button>
    </>
  );
}
```

Burada `count + 1` ifadesini bir deÄŸiÅŸkene (`nextCount`) kaydediyoruz ve hem `setCount` fonksiyonunda hem de `console.log` iÃ§inde aynÄ± deÄŸeri kullanÄ±yoruz. BÃ¶ylece, ekrana yazdÄ±rÄ±lan deÄŸer beklendiÄŸi gibi olur.

### React Neden State GÃ¼ncellemelerini Asenkron YapÄ±yor?

Bu asenkron Ã§alÄ±ÅŸma ÅŸekli, Reactâ€™in performansÄ±nÄ± artÄ±ran Ã¶nemli bir Ã¶zelliktir. Bunu daha iyi anlamak iÃ§in birden fazla state'in gÃ¼ncellendiÄŸi bir Ã¶rnek dÃ¼ÅŸÃ¼nelim:

```jsx
function App() {
  const [user, setUser] = React.useState({ name: 'Alyssa' });
  const [status, setStatus] = React.useState('ready');
  const [confirmationMessage, setConfirmationMessage] =
    React.useState();

  if (!user) {
    return <p>{confirmationMessage}</p>;
  }

  return (
    <button
      onClick={() => {
        setUser(null);
        setStatus('initial');
        setConfirmationMessage('You have been logged out.');
      }}
    >
      Log Out
    </button>
  );
}
```

### **BÃ¼tÃ¼n GÃ¼ncellemeler AynÄ± Anda YapÄ±lÄ±yor**

Bu kod Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda React'in ne yaptÄ±ÄŸÄ±nÄ± adÄ±m adÄ±m inceleyelim:

1. `setUser(null);` Ã§aÄŸrÄ±lÄ±r. React, bunu gÃ¼ncellenecek state'ler listesine ekler.
2. `setStatus('initial');` Ã§aÄŸrÄ±lÄ±r. React, listeye bir gÃ¼ncelleme daha ekler.
3. `setConfirmationMessage("You have been logged out.");` Ã§aÄŸrÄ±lÄ±r ve listeye eklenir.
4. **BÃ¼tÃ¼n state deÄŸiÅŸiklikleri bir arada iÅŸlenir ve tek bir re-render gerÃ§ekleÅŸir.**

EÄŸer React **gÃ¼ncellemeleri hemen yapsaydÄ±**, her `setState` Ã§aÄŸrÄ±sÄ±ndan sonra bileÅŸen tekrar render edilirdi. Bu da:

- **Performans kaybÄ±na** neden olurdu (3 kat daha fazla iÅŸ yapÄ±lÄ±rdÄ±!).
- **Tuhaf ve hatalÄ± arayÃ¼z davranÄ±ÅŸlarÄ± oluÅŸturabilirdi.** Ã–rneÄŸin, ilk gÃ¼ncelleme Ã§alÄ±ÅŸtÄ±ktan sonra `user` deÄŸeri `null` olurdu ama `confirmationMessage` henÃ¼z gÃ¼ncellenmediÄŸi iÃ§in **boÅŸ bir `<p>{undefined}</p>` etiketi oluÅŸurdu!**

Ä°ÅŸte bu yÃ¼zden React **state gÃ¼ncellemelerini toplu (batch) olarak iÅŸler ve bir defada render eder**. Bu, **hÄ±zlÄ± ve tutarlÄ± bir UI saÄŸlar!**

### Ã–zet

âœ… Reactâ€™te state gÃ¼ncellemeleri **asenkron** olarak gerÃ§ekleÅŸir.

âœ… `setState` fonksiyonlarÄ± hemen Ã§alÄ±ÅŸmaz; bir sonraki render iÃ§in gÃ¼ncellemeyi planlar.

âœ… EÄŸer gÃ¼ncellenmiÅŸ deÄŸere hemen eriÅŸmek istiyorsanÄ±z, onu bir deÄŸiÅŸkene kaydedin (`nextCount = count + 1`).

âœ… React, **batching (toplu iÅŸleme)** sayesinde performansÄ± artÄ±rÄ±r ve gereksiz render iÅŸlemlerini engeller.

BÃ¶ylece hem hÄ±zlÄ± hem de stabil bir kullanÄ±cÄ± deneyimi saÄŸlanÄ±r! ğŸš€
